
Build := {
    order: LoadSpec<[]{pack: PackID}>
    packs[]: PackManifest
    auxilary: {
        pack_map: {
            <PackID...>: PackManifest
        }
    }
}

PackManifest := {
    pack: PackID
    display: {
        name: string
        summary: string
    }
    url: string
    author: PackAuthor
    abstract: bool
    preferred_order: LoadSpec<RelativeOrder>
    dependencies[]: PackRequirement
    supports[]: PackRequirement
    implements[]: PackReference
}

PackAuthor := {
    name: string
    url? string
}

PackRequirement := {
    pack: PackID
    version: Version
    url: string
    order: LoadSpec<RelativeOrder>
}

PackReference := {
    pack: PackID
}

PackID := $namespace

Version := {
    major: int
    minor: int
    patch: int
}

LoadSpec<^T> := {
    pre_load: ^T
    load: ^T
    post_load: ^T
    tick: ^T
}

BuildEvaluationError := {
    duplicate_packs[]? {
        pack: PackID
        instances[]: PackManifest
    }
    multiple_implementations[]? {
        pack: PackID
        sources[]: PackManifest
    }
    dependency_cycles[]? {
        root: PackManifest
        cycle[]: PackID
    }
    order_conflicts? LoadSpec<[]{a: PackID, b: PackID}>
    missing_dependencies[]? {
        dependency: PackRequirement
        dependent: PackManifest
        bad_version? {
            installed: PackManifest
            versionIndex: 0b | 1b
        }
    }
    missing_implementations[]? PackManifest
}

ManifestInput := {
    pack: PackID
    version: Version
    author: PackAuthor
    display: {
        name: string
        summary: string
    }
    preferred_order? ManifestInputOrdering
    abstract? bool
    library? bool
    dependencies[]? ManifestInputPackRequirement
    supports[]? ManifestInputPackRequirment
    implements[]? ManifestInputPackReference
}

ManifestInputPackReference := PackReference | PackID

ManifestInputOrdering := {
    pre_load? ManifestInputRelativeOrder
    load? ManifestInputRelativeOrder
    post_load? ManifestInputRelativeOrder
    tick? ManifestInputRelativeOrder
}

ManifestInputPackRequirement := {
    pack: PackID
    version: Version
    url: string
    order? ManifestInputOrdering
}

ManifestInputRelativeOrder := 'AFTER' | 'BEFORE' | 'ANY' | 1 | -1 | 0 | RelativeOrder

RelativeOrder := -1b | 1b | 0b

UnsafeUninstall := {
    pack: PackID
    reason: {
        dependency_of[]? PackReference
        implements[]? PackReference
    }
}

ValidationError := {
    missing_data[]? {
        field: string
    }
    invalid_data[]? {
        field: string
        expected: string
        got: any
    }
}

PackManifestEvalError := ValidationError << {
    duplicate_dependencies[]? PackRequirement
    duplicate_implements[]? PackReference
    unspecified_implements[]? PackReference
}
