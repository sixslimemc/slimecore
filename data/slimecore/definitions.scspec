
Build := {
    order: LoadWords<[]{pack: $PackID}>
    packs[]: PackManifest
    auxilary: {
        pack_map: {
            <$PackID...>: PackManifest
        }
    }
}

PackManifest := {
    pack: $PackID
    display: {
        name: string
        summary: string
    }
    url: string
    author: PackAuthor
    abstract: bool
    preferred_order: LoadWords<RelativeOrder>
    dependencies[]: PackRequirement
    supports[]: PackRequirement
    implements[]: PackReference
}

LoadOrdering := LoadWords<RelativeOrder>

PackAuthor := {
    name: string
    url? string
}

PackRequirement := {
    pack: $PackID
    version: VersionRequirement
    url: string
    order: LoadWords<RelativeOrder>
}

PackReference := {
    pack: $PackID
}

$PackID := $namespace

Version := {
    major: int
    minor: int
    patch: int
}

VersionRequirement := {
    major: int
    minor: int
}

LoadWords<^T> := {
    pre_load: ^T
    load: ^T
    post_load: ^T
    tick: ^T
}

BuildEvaluationError := {
    duplicate_packs[]? {
        pack: $PackID
        instances[]: PackManifest
    }
    multiple_implementations[]? {
        pack: $PackID
        sources[]: PackManifest
    }
    dependency_cycles[]? {
        root: PackManifest
        cycle[]: $PackID
    }
    order_conflicts? LoadWords<[]{a: $PackID, b: $PackID}>
    missing_dependencies[]? {
        dependency: PackRequirement
        dependent: PackManifest
        bad_version? {
            installed: PackManifest
            versionIndex: 0b | 1b
        }
    }
    missing_implementations[]? PackManifest
}

InputManifest := {
    pack: $PackID
    version: Version
    author: PackAuthor
    display: {
        name: string
        summary: string
    }
    preferred_order? InputLoadOrdering
    abstract? bool
    library? bool
    dependencies[]? InputPackRequirement
    supports[]? InputPackRequirment
    implements[]? InputPackReference
}

InputPackReference := PackReference | $PackID

InputLoadOrdering := {
    pre_load? InputRelativeOrder
    load? InputRelativeOrder
    post_load? InputRelativeOrder
    tick? InputRelativeOrder
}

InputPackRequirement := {
    pack: $PackID
    version: VersionRequirement
    url: string
    order? InputLoadOrdering
}

InputRelativeOrder := 'AFTER' | 'BEFORE' | 'ANY' | 1 | -1 | 0 | RelativeOrder

RelativeOrder := -1b | 1b | 0b

UnsafeUninstall := {
    pack: $PackID
    reason: {
        dependency_of[]? PackReference
        implements[]? PackReference
    }
}

ValueValidationError := {
    invalid_value? {
        expected: string
        got: any
    }
}

CompoundValidationError := {
    missing_data[]? {
        key: string
    }
    invalid_data[]? {
        key: string
        expected: string
        got: any
    }
}

ManifestEvalError := ValidationError << {
    duplicate_dependencies[]? PackRequirement
    duplicate_implements[]? PackReference
    unspecified_implements[]? PackReference
}
