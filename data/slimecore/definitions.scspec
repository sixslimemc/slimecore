
Build := {
    order: LoadSpec<[]{pack: PackID}>
    packs[]: PackInfo
    auxilary: {
        pack_map: {
            <PackID...>: PackInfo
        }
    }
}

PackInfo := {
    pack: PackID
    display: {
        name: string
        summary: string
    }
    url: string
    author: PackAuthor
    abstract: bool
    preferred_order: LoadSpec<RelativeOrder>
    dependencies[]: PackRequirement
    supports[]: PackRequirement
    implements[]: PackReference
}

PackAuthor := {
    name: string
    url? string
}

PackRequirement := {
    pack: PackID
    version: Version
    url: string
    order: LoadSpec<RelativeOrder>
}

PackReference := {
    pack: PackID
}

PackID := $namespace

Version := {
    major: int
    minor: int
    patch: int
}

LoadSpec<^T> := {
    pre_load: ^T
    load: ^T
    post_load: ^T
    tick: ^T
}

BuildEvaluationError := {
    duplicate_packs[]? {
        pack: PackID
        instances[]: PackInfo
    }
    multiple_implementations[]? {
        pack: PackID
        sources[]: PackInfo
    }
    dependency_cycles[]? {
        root: PackInfo
        cycle[]: PackID
    }
    order_conflicts? LoadSpec<[]{a: PackID, b: PackID}>
    missing_dependencies[]? {
        dependency: PackRequirement
        dependent: PackInfo
        bad_version? {
            installed: PackInfo
            versionIndex: 0b | 1b
        }
    }
    missing_implementations[]? PackInfo
}

Manifest := {
    pack: PackID
    version: Version
    display: {
        name: string
        summary: string
    }
    author: PackAuthor
    abstract? bool
    library? bool
    dependencies[]? ManifestPackRequirement
    supports[]? ManifestPackRequirment
    implements[]? ManifestPackReference
}

ManifestPackReference := PackReference | PackID

ManifestOrdering := {
    pre_load? ManifestRelativeOrder
    load? ManifestRelativeOrder
    post_load? ManifestRelativeOrder
    tick? ManifestRelativeOrder
}

ManifestPackRequirement := {
    pack: PackID
    version: Version
    url: string
    order? ManifestOrdering
}

ManifestRelativeOrder := 'AFTER' | 'BEFORE' | 'ANY' | RelativeOrder

RelativeOrder := -1b | 1b | 0b

UnsafeUninstall := {
    pack: PackID
    reason: {
        dependency_of[]? PackReference
        implements[]? PackReference
    }
}

ValidationError := {
    missing_data[]? {
        field: string
    }
    invalid_data[]? {
        field: string
        expected: string
        got: any
    }
}

ManifestEvalError := ValidationError << {
    duplicate_dependencies[]? PackRequirement
    duplicate_implements[]? PackReference
    unspecified_implements[]? PackReference
}
