
Build: {
    order: LoadSpec<[]{pack: PackID}>
    packs[]: PackInfo
    auxilary: {
        pack_map: {
            <PackID...>: PackInfo
        }
    }
}

PackInfo := {
    pack: PackID
    display_name: string
    url: string
    author: PackAuthor
    abstract: bool
    dependencies[]: PackRequirement
    supports[]: PackRequirement
    implements[]: PackReference
}

PackAuthor := {
    display_name: string
    url? string
}

PackRequirement := {
    pack: PackID
    version: Version
    url: string
    order: LoadSpec<RelativeOrder>
}

PackReference := {
    pack: PackID
}

PackID := $namespace

Version := {
    major: int
    minor: int
    patch: int
}

LoadSpec<&T> := {
    pre_load: &T
    load: &T
    post_load: &T
    tick: &T
}

BuildEvaluationError := {
    duplicate_packs[]? {
        pack: PackID
        instances[]: PackInfo
    }
    multiple_implementations[]? {
        pack: PackID
        sources[]: PackInfo
    }
    dependency_cycles[]? {
        root: PackInfo
        cycle[]: PackID
    }
    order_conflicts? LoadSpec<[]{a: PackID, b: PackID}>
    missing_dependencies[]? {
        dependency: PackRequirement
        dependent: PackInfo
        bad_version? {
            installed: PackInfo
            versionIndex: 0b | 1b
        }
    }
    missing_implementations[]? PackInfo
}

ManifestEvaluationError := {
    missing_data[]? {
        field: string
    }
    invalid_data[]? {
        field: string
        expected: string
        got: any
    }
    duplicate_dependencies[]? PackRequirement
    duplicate_implements[]? PackReference
    unspecified_implements[]? PackReference
}

ManifestPackRequirement := PackRequirement << {
    order? LoadSpec<ManifestOrderRequirement = 1b> = LoadSpec<1b>
}

ManifestRelativeOrder := 'AFTER' | 'BEFORE' | 'ANY' | RelativeOrder

RelativeOrder := -1b | 1b | 0b