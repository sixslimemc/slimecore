
@_ {
    cache: {
        this_build: {
            manifests[]: PackInfo
                # value of {..manifests}.
                
        }
        # information about the last working build.

    }

    build: {
        in: {
            manifests[]: PackInfo
        }
        # build inputs.

        out: {
            
        }
        # build outputs.

    }
    # interaction with ':_/build/main'

    manifests: {
        valid[]: PackInfo
        invalid[]: {
            error: ManifestEvaluationError
            manifest: Manifest
        }
    }
    # ':manifest' function adds to this at manifest-time.

    util: {
        <function name...>: {
            in: {
                ...
            }
            out: {
                ...
            }
        }
    }
    # for interacting with _/util/**
    
    impl: {
        ...
    }
    # vars for _/impl/**.

    var: {
        ...
    }
    # vars for  _/[!"impl"]**

    const: {
        alphabet: {
            max_index: 28
            map: {
                <[a-z, ., -, _]>: <0..{max_index}>
            }
            # for sorting initial pack order alphabetically (for deterministic load order)

            empty_buffer[{max_index}+1]: []
                # array of empty arrays large enough to be safely alphabet indexed
        }
        load_words= ['pre_load', 'load', 'post_load', 'tick']
            # load words; must match up with keys in LoadSpec
        load_tags= [
            {word: 'tick', tag: 'tick_start'},
            {word: 'post_load', tag: 'post_load'},
            {word: 'load', tag: 'load'},
            {word: 'pre_load', tag: 'pre_load'}
        ]
            # associations between loading tags and their load words, in *reverse* order in which they are called.
    }
}