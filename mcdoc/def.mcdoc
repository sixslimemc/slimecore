type PackId = #[matches_regex="^(?!minecraft$)(?!slimecore$)[a-z0-9-]{1,64}$"] string
type PackUrl = string
type ExternalLink = string
type IdFormat = #[matches_regex="^[a-z0-9-]{1,64}$"] string
type AuthorId = IdFormat
type AbstractId = IdFormat
type EntrypointId = IdFormat
type PreloadEntrypointId = IdFormat
type DatapackPath = string
type EvalResult<T, E> = (struct {success: T} | struct {error: E})
type PositiveInt = int @ 0..

type Indexed<T> = struct {
    index: int @ 0..,
    ...T
}

type EntrypointReference<T> = struct {
    ...PackReference,
    id: T
}
type EntrypointDeclaration<T> = struct {
    id: T,
    before?: [EntrypointReference<T>],
    after?: [EntrypointReference<T>],
}

struct DatapackLink {
    ...PackReference,
    path: DatapackPath
}
struct PartialPackInfo {
    pack_id: PackId,
    author_id: AuthorId,
    version: Version,
}
struct PackReference {
    pack_ref: PackId,
}

struct AbstractDeclaration {
    id: AbstractId
}

struct AbstractReference {
    ...PackReference,
    id: AbstractId,
}
struct Version {
    major: PositiveInt,
    minor: PositiveInt,
    patch: PositiveInt,
}

struct VersionRequirement {
    major: PositiveInt,
    minor: PositiveInt,
}

struct PackManifest {
    pack_id: PackId,
    author_id: AuthorId,
    version: Version,
    url: PackUrl,
    display: struct PackDisplayInfo {
        name: string,
        author_name: string,
        summary: string,
        links: struct {
            author?: ExternalLink,
            versions?: ExternalLink,
            info?: ExternalLink,
        }
    },
    entrypoints: [EntrypointDeclaration<EntrypointId>],
    preload_entrypoints: [EntrypointDeclaration<PreloadEntrypointId>],
    is_library: boolean,
    abstract_declarations: [AbstractDeclaration],
    abstract_implementations: [AbstractReference],
    dependencies: [Dependency]
}

struct Dependency {
    pack_id: PackId,
    author_id: AuthorId,
    version: VersionRequirement,
    download: struct {
        url: PackUrl,
        version: Version
    },
    optional: boolean,
}

struct BuildInfo {
    // packs are in load order.
    packs: [PackManifest],
    order: struct {
        load: [Indexed<PackReference>],
        entrypoints: [Indexed<EntrypointReference<EntrypointId>>],
        preload_entrypoints: [Indexed<EntrypointReference<PreloadEntrypointId>>]
    },
    aux: struct {
        pack_map: struct {
            [PackId]: PackManifest
        },
        impl_map: struct {
            [PackId]: struct {
                [AbstractId]: PackManifest
            }
        }
    }
}

struct WorldSpecificInfo {
    disabled_packs: [PartialPackInfo],
    datapack_links: [DatapackLink],
    aux: struct {
        datapack_link_map: struct {
            [PackId]: DatapackPath
        }
    }
}
