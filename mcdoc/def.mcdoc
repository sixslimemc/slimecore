type PackId = #[matches_regex="^(?!minecraft$)(?!slimecore$)[a-z0-9-]{1,64}$"] string
type PackUrl = string
type ExternalLink = string
type IdFormat = #[matches_regex="^[a-z0-9-]{1,64}$"] string
type AuthorId = #[matches_regex="^(?!sixslime$)[a-z0-9-]{1,64}$"] string
type AbstractInterfaceId = IdFormat
type EntrypointId = IdFormat
type PreloadEntrypointId = IdFormat
type DatapackPath = string
type EvalResult<T, E> = (struct {success: T} | struct {error: E})

type DependencyEntrypointReference<T> = struct {
    ...PackReference,
    id: T
}
type EntrypointDeclaration<T> = struct {
    id: T,
    before?: [DependencyEntrypointReference<T>],
    after?: [DependencyEntrypointReference<T>],
}

struct PackReference {
    pack_ref: PackId,
}

struct AbstractInterfaceReference {
    ...PackReference,
    id: AbstractInterfaceId,
}
struct Version {
    major: int @ 0..,
    minor: int @ 0..,
    patch: int @ 0..,
}

struct VersionRequirement {
    major: int @ 0..,
    minor: int @ 0..,
}

struct PackManifest {
    pack_id: PackId,
    author: AuthorId,
    version: Version,
    url: PackUrl,
    display: struct PackDisplayInfo {
        name: string,
        author_name: string,
        summary: string,
        links: struct {
            author?: ExternalLink,
            versions?: ExternalLink,
            info?: ExternalLink,
        }
    },
    entrypoints: [EntrypointDeclaration<EntrypointId>],
    preload_entrypoints: [EntrypointDeclaration<PreloadEntrypointId>],
    is_library: boolean,
    abstract_declarations: [AbstractInterfaceId],
    abstract_implementations: [AbstractInterfaceReference],
    dependencies: [Dependency]
}

struct Dependency {
    pack_id: PackId,
    author: AuthorId,
    version: VersionRequirement,
    download: struct {
        url: PackUrl,
        version: Version
    },
    optional: boolean,
}

struct BuildInfo {
    packs: [PackManifest],
    order: struct {
        // kind a just a formality, 'packs' should be in load order anyway
        load: [struct {
            ...PackReference,
            index: int @ 0..
        }],
        entrypoints: [struct {
            ...PackReference,
            id: EntrypointId,
            index: int @ 0..,
        }],
        preload_entrypoints: [struct {
            ...PackReference,
            id: PreloadEntrypointId,
            index: int @ 0..,
        }]
    },
    aux: struct {
        packmap: struct {
            [PackId]: PackManifest
        }
    }
}

struct WorldSpecificInfo {
    pathmap: struct {
        [PackId]: DatapackPath
    }
}
